/**
 * Generated by orval v8.4.0 ðŸº
 * Do not edit manually.
 * Whendoist
 * OpenAPI spec version: 0.54.5
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BatchAction,
  BatchCompleteRequest,
  BatchCompleteResponse,
  BatchPastResponse,
  HTTPValidationError,
  InstanceResponse,
  InstanceSchedule,
  InstanceStatusResponse,
  InstanceToggleCompleteResponse,
  ListInstancesApiV1InstancesGetParams,
  PendingPastCountResponse
} from '../../model';

import { apiClient } from '../../../lib/api-client';




/**
 * Get task instances for a date range.
 * @summary List Instances
 */
export const listInstancesApiV1InstancesGet = (
    params: ListInstancesApiV1InstancesGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<InstanceResponse[]>(
      {url: `/api/v1/instances`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListInstancesApiV1InstancesGetQueryKey = (params?: ListInstancesApiV1InstancesGetParams,) => {
    return [
    `/api/v1/instances`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListInstancesApiV1InstancesGetQueryOptions = <TData = Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError = HTTPValidationError>(params: ListInstancesApiV1InstancesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListInstancesApiV1InstancesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>> = ({ signal }) => listInstancesApiV1InstancesGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInstancesApiV1InstancesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>>
export type ListInstancesApiV1InstancesGetQueryError = HTTPValidationError


export function useListInstancesApiV1InstancesGet<TData = Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError = HTTPValidationError>(
 params: ListInstancesApiV1InstancesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>,
          TError,
          Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInstancesApiV1InstancesGet<TData = Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError = HTTPValidationError>(
 params: ListInstancesApiV1InstancesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>,
          TError,
          Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInstancesApiV1InstancesGet<TData = Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError = HTTPValidationError>(
 params: ListInstancesApiV1InstancesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Instances
 */

export function useListInstancesApiV1InstancesGet<TData = Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError = HTTPValidationError>(
 params: ListInstancesApiV1InstancesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstancesApiV1InstancesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListInstancesApiV1InstancesGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Complete a specific instance of a recurring task.
 * @summary Complete Instance
 */
export const completeInstanceApiV1InstancesInstanceIdCompletePost = (
    instanceId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<InstanceStatusResponse>(
      {url: `/api/v1/instances/${instanceId}/complete`, method: 'POST', signal
    },
      );
    }
  


export const getCompleteInstanceApiV1InstancesInstanceIdCompletePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeInstanceApiV1InstancesInstanceIdCompletePost>>, TError,{instanceId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof completeInstanceApiV1InstancesInstanceIdCompletePost>>, TError,{instanceId: number}, TContext> => {

const mutationKey = ['completeInstanceApiV1InstancesInstanceIdCompletePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeInstanceApiV1InstancesInstanceIdCompletePost>>, {instanceId: number}> = (props) => {
          const {instanceId} = props ?? {};

          return  completeInstanceApiV1InstancesInstanceIdCompletePost(instanceId,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteInstanceApiV1InstancesInstanceIdCompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof completeInstanceApiV1InstancesInstanceIdCompletePost>>>
    
    export type CompleteInstanceApiV1InstancesInstanceIdCompletePostMutationError = HTTPValidationError

    /**
 * @summary Complete Instance
 */
export const useCompleteInstanceApiV1InstancesInstanceIdCompletePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeInstanceApiV1InstancesInstanceIdCompletePost>>, TError,{instanceId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeInstanceApiV1InstancesInstanceIdCompletePost>>,
        TError,
        {instanceId: number},
        TContext
      > => {
      return useMutation(getCompleteInstanceApiV1InstancesInstanceIdCompletePostMutationOptions(options), queryClient);
    }
    /**
 * Uncomplete a specific instance of a recurring task.
 * @summary Uncomplete Instance
 */
export const uncompleteInstanceApiV1InstancesInstanceIdUncompletePost = (
    instanceId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<InstanceStatusResponse>(
      {url: `/api/v1/instances/${instanceId}/uncomplete`, method: 'POST', signal
    },
      );
    }
  


export const getUncompleteInstanceApiV1InstancesInstanceIdUncompletePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uncompleteInstanceApiV1InstancesInstanceIdUncompletePost>>, TError,{instanceId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uncompleteInstanceApiV1InstancesInstanceIdUncompletePost>>, TError,{instanceId: number}, TContext> => {

const mutationKey = ['uncompleteInstanceApiV1InstancesInstanceIdUncompletePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uncompleteInstanceApiV1InstancesInstanceIdUncompletePost>>, {instanceId: number}> = (props) => {
          const {instanceId} = props ?? {};

          return  uncompleteInstanceApiV1InstancesInstanceIdUncompletePost(instanceId,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UncompleteInstanceApiV1InstancesInstanceIdUncompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof uncompleteInstanceApiV1InstancesInstanceIdUncompletePost>>>
    
    export type UncompleteInstanceApiV1InstancesInstanceIdUncompletePostMutationError = HTTPValidationError

    /**
 * @summary Uncomplete Instance
 */
export const useUncompleteInstanceApiV1InstancesInstanceIdUncompletePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uncompleteInstanceApiV1InstancesInstanceIdUncompletePost>>, TError,{instanceId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uncompleteInstanceApiV1InstancesInstanceIdUncompletePost>>,
        TError,
        {instanceId: number},
        TContext
      > => {
      return useMutation(getUncompleteInstanceApiV1InstancesInstanceIdUncompletePostMutationOptions(options), queryClient);
    }
    /**
 * Toggle an instance's completion status.
 * @summary Toggle Instance Complete
 */
export const toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost = (
    instanceId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<InstanceToggleCompleteResponse>(
      {url: `/api/v1/instances/${instanceId}/toggle-complete`, method: 'POST', signal
    },
      );
    }
  


export const getToggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost>>, TError,{instanceId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost>>, TError,{instanceId: number}, TContext> => {

const mutationKey = ['toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost>>, {instanceId: number}> = (props) => {
          const {instanceId} = props ?? {};

          return  toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost(instanceId,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ToggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost>>>
    
    export type ToggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePostMutationError = HTTPValidationError

    /**
 * @summary Toggle Instance Complete
 */
export const useToggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost>>, TError,{instanceId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof toggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePost>>,
        TError,
        {instanceId: number},
        TContext
      > => {
      return useMutation(getToggleInstanceCompleteApiV1InstancesInstanceIdToggleCompletePostMutationOptions(options), queryClient);
    }
    /**
 * Skip a specific instance of a recurring task.
 * @summary Skip Instance
 */
export const skipInstanceApiV1InstancesInstanceIdSkipPost = (
    instanceId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<InstanceStatusResponse>(
      {url: `/api/v1/instances/${instanceId}/skip`, method: 'POST', signal
    },
      );
    }
  


export const getSkipInstanceApiV1InstancesInstanceIdSkipPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skipInstanceApiV1InstancesInstanceIdSkipPost>>, TError,{instanceId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof skipInstanceApiV1InstancesInstanceIdSkipPost>>, TError,{instanceId: number}, TContext> => {

const mutationKey = ['skipInstanceApiV1InstancesInstanceIdSkipPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skipInstanceApiV1InstancesInstanceIdSkipPost>>, {instanceId: number}> = (props) => {
          const {instanceId} = props ?? {};

          return  skipInstanceApiV1InstancesInstanceIdSkipPost(instanceId,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SkipInstanceApiV1InstancesInstanceIdSkipPostMutationResult = NonNullable<Awaited<ReturnType<typeof skipInstanceApiV1InstancesInstanceIdSkipPost>>>
    
    export type SkipInstanceApiV1InstancesInstanceIdSkipPostMutationError = HTTPValidationError

    /**
 * @summary Skip Instance
 */
export const useSkipInstanceApiV1InstancesInstanceIdSkipPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skipInstanceApiV1InstancesInstanceIdSkipPost>>, TError,{instanceId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skipInstanceApiV1InstancesInstanceIdSkipPost>>,
        TError,
        {instanceId: number},
        TContext
      > => {
      return useMutation(getSkipInstanceApiV1InstancesInstanceIdSkipPostMutationOptions(options), queryClient);
    }
    /**
 * Unskip a specific instance (revert skip, mark as pending).
 * @summary Unskip Instance
 */
export const unskipInstanceApiV1InstancesInstanceIdUnskipPost = (
    instanceId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<InstanceStatusResponse>(
      {url: `/api/v1/instances/${instanceId}/unskip`, method: 'POST', signal
    },
      );
    }
  


export const getUnskipInstanceApiV1InstancesInstanceIdUnskipPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unskipInstanceApiV1InstancesInstanceIdUnskipPost>>, TError,{instanceId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof unskipInstanceApiV1InstancesInstanceIdUnskipPost>>, TError,{instanceId: number}, TContext> => {

const mutationKey = ['unskipInstanceApiV1InstancesInstanceIdUnskipPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unskipInstanceApiV1InstancesInstanceIdUnskipPost>>, {instanceId: number}> = (props) => {
          const {instanceId} = props ?? {};

          return  unskipInstanceApiV1InstancesInstanceIdUnskipPost(instanceId,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UnskipInstanceApiV1InstancesInstanceIdUnskipPostMutationResult = NonNullable<Awaited<ReturnType<typeof unskipInstanceApiV1InstancesInstanceIdUnskipPost>>>
    
    export type UnskipInstanceApiV1InstancesInstanceIdUnskipPostMutationError = HTTPValidationError

    /**
 * @summary Unskip Instance
 */
export const useUnskipInstanceApiV1InstancesInstanceIdUnskipPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unskipInstanceApiV1InstancesInstanceIdUnskipPost>>, TError,{instanceId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unskipInstanceApiV1InstancesInstanceIdUnskipPost>>,
        TError,
        {instanceId: number},
        TContext
      > => {
      return useMutation(getUnskipInstanceApiV1InstancesInstanceIdUnskipPostMutationOptions(options), queryClient);
    }
    /**
 * Reschedule a specific instance.
 * @summary Schedule Instance
 */
export const scheduleInstanceApiV1InstancesInstanceIdSchedulePut = (
    instanceId: number,
    instanceSchedule: InstanceSchedule,
 signal?: AbortSignal
) => {
      
      
      return apiClient<InstanceResponse>(
      {url: `/api/v1/instances/${instanceId}/schedule`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: instanceSchedule, signal
    },
      );
    }
  


export const getScheduleInstanceApiV1InstancesInstanceIdSchedulePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scheduleInstanceApiV1InstancesInstanceIdSchedulePut>>, TError,{instanceId: number;data: InstanceSchedule}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof scheduleInstanceApiV1InstancesInstanceIdSchedulePut>>, TError,{instanceId: number;data: InstanceSchedule}, TContext> => {

const mutationKey = ['scheduleInstanceApiV1InstancesInstanceIdSchedulePut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scheduleInstanceApiV1InstancesInstanceIdSchedulePut>>, {instanceId: number;data: InstanceSchedule}> = (props) => {
          const {instanceId,data} = props ?? {};

          return  scheduleInstanceApiV1InstancesInstanceIdSchedulePut(instanceId,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ScheduleInstanceApiV1InstancesInstanceIdSchedulePutMutationResult = NonNullable<Awaited<ReturnType<typeof scheduleInstanceApiV1InstancesInstanceIdSchedulePut>>>
    export type ScheduleInstanceApiV1InstancesInstanceIdSchedulePutMutationBody = InstanceSchedule
    export type ScheduleInstanceApiV1InstancesInstanceIdSchedulePutMutationError = HTTPValidationError

    /**
 * @summary Schedule Instance
 */
export const useScheduleInstanceApiV1InstancesInstanceIdSchedulePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scheduleInstanceApiV1InstancesInstanceIdSchedulePut>>, TError,{instanceId: number;data: InstanceSchedule}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof scheduleInstanceApiV1InstancesInstanceIdSchedulePut>>,
        TError,
        {instanceId: number;data: InstanceSchedule},
        TContext
      > => {
      return useMutation(getScheduleInstanceApiV1InstancesInstanceIdSchedulePutMutationOptions(options), queryClient);
    }
    /**
 * Complete all pending instances for a task before a given date.
 * @summary Batch Complete Instances
 */
export const batchCompleteInstancesApiV1InstancesBatchCompletePost = (
    batchCompleteRequest: BatchCompleteRequest,
 signal?: AbortSignal
) => {
      
      
      return apiClient<BatchCompleteResponse>(
      {url: `/api/v1/instances/batch-complete`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: batchCompleteRequest, signal
    },
      );
    }
  


export const getBatchCompleteInstancesApiV1InstancesBatchCompletePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchCompleteInstancesApiV1InstancesBatchCompletePost>>, TError,{data: BatchCompleteRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof batchCompleteInstancesApiV1InstancesBatchCompletePost>>, TError,{data: BatchCompleteRequest}, TContext> => {

const mutationKey = ['batchCompleteInstancesApiV1InstancesBatchCompletePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof batchCompleteInstancesApiV1InstancesBatchCompletePost>>, {data: BatchCompleteRequest}> = (props) => {
          const {data} = props ?? {};

          return  batchCompleteInstancesApiV1InstancesBatchCompletePost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BatchCompleteInstancesApiV1InstancesBatchCompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof batchCompleteInstancesApiV1InstancesBatchCompletePost>>>
    export type BatchCompleteInstancesApiV1InstancesBatchCompletePostMutationBody = BatchCompleteRequest
    export type BatchCompleteInstancesApiV1InstancesBatchCompletePostMutationError = HTTPValidationError

    /**
 * @summary Batch Complete Instances
 */
export const useBatchCompleteInstancesApiV1InstancesBatchCompletePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchCompleteInstancesApiV1InstancesBatchCompletePost>>, TError,{data: BatchCompleteRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof batchCompleteInstancesApiV1InstancesBatchCompletePost>>,
        TError,
        {data: BatchCompleteRequest},
        TContext
      > => {
      return useMutation(getBatchCompleteInstancesApiV1InstancesBatchCompletePostMutationOptions(options), queryClient);
    }
    /**
 * Count pending instances from past days across all tasks.
 * @summary Pending Past Count
 */
export const pendingPastCountApiV1InstancesPendingPastCountGet = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<PendingPastCountResponse>(
      {url: `/api/v1/instances/pending-past-count`, method: 'GET', signal
    },
      );
    }
  



export const getPendingPastCountApiV1InstancesPendingPastCountGetQueryKey = () => {
    return [
    `/api/v1/instances/pending-past-count`
    ] as const;
    }

    
export const getPendingPastCountApiV1InstancesPendingPastCountGetQueryOptions = <TData = Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPendingPastCountApiV1InstancesPendingPastCountGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>> = ({ signal }) => pendingPastCountApiV1InstancesPendingPastCountGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PendingPastCountApiV1InstancesPendingPastCountGetQueryResult = NonNullable<Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>>
export type PendingPastCountApiV1InstancesPendingPastCountGetQueryError = unknown


export function usePendingPastCountApiV1InstancesPendingPastCountGet<TData = Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>,
          TError,
          Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePendingPastCountApiV1InstancesPendingPastCountGet<TData = Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>,
          TError,
          Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePendingPastCountApiV1InstancesPendingPastCountGet<TData = Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Pending Past Count
 */

export function usePendingPastCountApiV1InstancesPendingPastCountGet<TData = Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pendingPastCountApiV1InstancesPendingPastCountGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPendingPastCountApiV1InstancesPendingPastCountGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Complete or skip all pending past instances across all tasks.
 * @summary Batch Past Instances
 */
export const batchPastInstancesApiV1InstancesBatchPastPost = (
    batchAction: BatchAction,
 signal?: AbortSignal
) => {
      
      
      return apiClient<BatchPastResponse>(
      {url: `/api/v1/instances/batch-past`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: batchAction, signal
    },
      );
    }
  


export const getBatchPastInstancesApiV1InstancesBatchPastPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchPastInstancesApiV1InstancesBatchPastPost>>, TError,{data: BatchAction}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof batchPastInstancesApiV1InstancesBatchPastPost>>, TError,{data: BatchAction}, TContext> => {

const mutationKey = ['batchPastInstancesApiV1InstancesBatchPastPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof batchPastInstancesApiV1InstancesBatchPastPost>>, {data: BatchAction}> = (props) => {
          const {data} = props ?? {};

          return  batchPastInstancesApiV1InstancesBatchPastPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BatchPastInstancesApiV1InstancesBatchPastPostMutationResult = NonNullable<Awaited<ReturnType<typeof batchPastInstancesApiV1InstancesBatchPastPost>>>
    export type BatchPastInstancesApiV1InstancesBatchPastPostMutationBody = BatchAction
    export type BatchPastInstancesApiV1InstancesBatchPastPostMutationError = HTTPValidationError

    /**
 * @summary Batch Past Instances
 */
export const useBatchPastInstancesApiV1InstancesBatchPastPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchPastInstancesApiV1InstancesBatchPastPost>>, TError,{data: BatchAction}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof batchPastInstancesApiV1InstancesBatchPastPost>>,
        TError,
        {data: BatchAction},
        TContext
      > => {
      return useMutation(getBatchPastInstancesApiV1InstancesBatchPastPostMutationOptions(options), queryClient);
    }
    