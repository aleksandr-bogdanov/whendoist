/**
 * Generated by orval v8.4.0 ðŸº
 * Do not edit manually.
 * Whendoist
 * WHEN do I do my tasks?
 * OpenAPI spec version: 0.47.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BatchUpdateDomainsRequest,
  DomainCreate,
  DomainResponse,
  DomainUpdate,
  HTTPValidationError,
  ListDomainsApiV1DomainsGetParams
} from '../../model';

import { apiClient } from '../../../lib/api-client';




/**
 * Get all domains for the current user.
 * @summary List Domains
 */
export const listDomainsApiV1DomainsGet = (
    params?: ListDomainsApiV1DomainsGetParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<DomainResponse[]>(
      {url: `/api/v1/domains`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListDomainsApiV1DomainsGetQueryKey = (params?: ListDomainsApiV1DomainsGetParams,) => {
    return [
    `/api/v1/domains`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListDomainsApiV1DomainsGetQueryOptions = <TData = Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError = HTTPValidationError>(params?: ListDomainsApiV1DomainsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDomainsApiV1DomainsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>> = ({ signal }) => listDomainsApiV1DomainsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListDomainsApiV1DomainsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>>
export type ListDomainsApiV1DomainsGetQueryError = HTTPValidationError


export function useListDomainsApiV1DomainsGet<TData = Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError = HTTPValidationError>(
 params: undefined |  ListDomainsApiV1DomainsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>,
          TError,
          Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDomainsApiV1DomainsGet<TData = Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError = HTTPValidationError>(
 params?: ListDomainsApiV1DomainsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>,
          TError,
          Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDomainsApiV1DomainsGet<TData = Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError = HTTPValidationError>(
 params?: ListDomainsApiV1DomainsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Domains
 */

export function useListDomainsApiV1DomainsGet<TData = Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError = HTTPValidationError>(
 params?: ListDomainsApiV1DomainsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDomainsApiV1DomainsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListDomainsApiV1DomainsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Create a new domain.
 * @summary Create Domain
 */
export const createDomainApiV1DomainsPost = (
    domainCreate: DomainCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<DomainResponse>(
      {url: `/api/v1/domains`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: domainCreate, signal
    },
      );
    }
  


export const getCreateDomainApiV1DomainsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDomainApiV1DomainsPost>>, TError,{data: DomainCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDomainApiV1DomainsPost>>, TError,{data: DomainCreate}, TContext> => {

const mutationKey = ['createDomainApiV1DomainsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDomainApiV1DomainsPost>>, {data: DomainCreate}> = (props) => {
          const {data} = props ?? {};

          return  createDomainApiV1DomainsPost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDomainApiV1DomainsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createDomainApiV1DomainsPost>>>
    export type CreateDomainApiV1DomainsPostMutationBody = DomainCreate
    export type CreateDomainApiV1DomainsPostMutationError = HTTPValidationError

    /**
 * @summary Create Domain
 */
export const useCreateDomainApiV1DomainsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDomainApiV1DomainsPost>>, TError,{data: DomainCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDomainApiV1DomainsPost>>,
        TError,
        {data: DomainCreate},
        TContext
      > => {
      return useMutation(getCreateDomainApiV1DomainsPostMutationOptions(options), queryClient);
    }
    /**
 * Get a single domain by ID.
 * @summary Get Domain
 */
export const getDomainApiV1DomainsDomainIdGet = (
    domainId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<DomainResponse>(
      {url: `/api/v1/domains/${domainId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetDomainApiV1DomainsDomainIdGetQueryKey = (domainId: number,) => {
    return [
    `/api/v1/domains/${domainId}`
    ] as const;
    }

    
export const getGetDomainApiV1DomainsDomainIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError = HTTPValidationError>(domainId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDomainApiV1DomainsDomainIdGetQueryKey(domainId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>> = ({ signal }) => getDomainApiV1DomainsDomainIdGet(domainId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(domainId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDomainApiV1DomainsDomainIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>>
export type GetDomainApiV1DomainsDomainIdGetQueryError = HTTPValidationError


export function useGetDomainApiV1DomainsDomainIdGet<TData = Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError = HTTPValidationError>(
 domainId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDomainApiV1DomainsDomainIdGet<TData = Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError = HTTPValidationError>(
 domainId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDomainApiV1DomainsDomainIdGet<TData = Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError = HTTPValidationError>(
 domainId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Domain
 */

export function useGetDomainApiV1DomainsDomainIdGet<TData = Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError = HTTPValidationError>(
 domainId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDomainApiV1DomainsDomainIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDomainApiV1DomainsDomainIdGetQueryOptions(domainId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Update a domain.
 * @summary Update Domain
 */
export const updateDomainApiV1DomainsDomainIdPut = (
    domainId: number,
    domainUpdate: DomainUpdate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<DomainResponse>(
      {url: `/api/v1/domains/${domainId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: domainUpdate, signal
    },
      );
    }
  


export const getUpdateDomainApiV1DomainsDomainIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDomainApiV1DomainsDomainIdPut>>, TError,{domainId: number;data: DomainUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDomainApiV1DomainsDomainIdPut>>, TError,{domainId: number;data: DomainUpdate}, TContext> => {

const mutationKey = ['updateDomainApiV1DomainsDomainIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDomainApiV1DomainsDomainIdPut>>, {domainId: number;data: DomainUpdate}> = (props) => {
          const {domainId,data} = props ?? {};

          return  updateDomainApiV1DomainsDomainIdPut(domainId,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDomainApiV1DomainsDomainIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateDomainApiV1DomainsDomainIdPut>>>
    export type UpdateDomainApiV1DomainsDomainIdPutMutationBody = DomainUpdate
    export type UpdateDomainApiV1DomainsDomainIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Domain
 */
export const useUpdateDomainApiV1DomainsDomainIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDomainApiV1DomainsDomainIdPut>>, TError,{domainId: number;data: DomainUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDomainApiV1DomainsDomainIdPut>>,
        TError,
        {domainId: number;data: DomainUpdate},
        TContext
      > => {
      return useMutation(getUpdateDomainApiV1DomainsDomainIdPutMutationOptions(options), queryClient);
    }
    /**
 * Archive a domain (soft delete).
 * @summary Delete Domain
 */
export const deleteDomainApiV1DomainsDomainIdDelete = (
    domainId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `/api/v1/domains/${domainId}`, method: 'DELETE', signal
    },
      );
    }
  


export const getDeleteDomainApiV1DomainsDomainIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDomainApiV1DomainsDomainIdDelete>>, TError,{domainId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDomainApiV1DomainsDomainIdDelete>>, TError,{domainId: number}, TContext> => {

const mutationKey = ['deleteDomainApiV1DomainsDomainIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDomainApiV1DomainsDomainIdDelete>>, {domainId: number}> = (props) => {
          const {domainId} = props ?? {};

          return  deleteDomainApiV1DomainsDomainIdDelete(domainId,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDomainApiV1DomainsDomainIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDomainApiV1DomainsDomainIdDelete>>>
    
    export type DeleteDomainApiV1DomainsDomainIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Domain
 */
export const useDeleteDomainApiV1DomainsDomainIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDomainApiV1DomainsDomainIdDelete>>, TError,{domainId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDomainApiV1DomainsDomainIdDelete>>,
        TError,
        {domainId: number},
        TContext
      > => {
      return useMutation(getDeleteDomainApiV1DomainsDomainIdDeleteMutationOptions(options), queryClient);
    }
    /**
 * Batch update domain names.

Used when enabling encryption (to save encrypted names) or
disabling encryption (to save decrypted names).

Commits after each item to prevent connection timeouts.
Returns count of domains updated.
 * @summary Batch Update Domains
 */
export const batchUpdateDomainsApiV1DomainsBatchUpdatePost = (
    batchUpdateDomainsRequest: BatchUpdateDomainsRequest,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/api/v1/domains/batch-update`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: batchUpdateDomainsRequest, signal
    },
      );
    }
  


export const getBatchUpdateDomainsApiV1DomainsBatchUpdatePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchUpdateDomainsApiV1DomainsBatchUpdatePost>>, TError,{data: BatchUpdateDomainsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof batchUpdateDomainsApiV1DomainsBatchUpdatePost>>, TError,{data: BatchUpdateDomainsRequest}, TContext> => {

const mutationKey = ['batchUpdateDomainsApiV1DomainsBatchUpdatePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof batchUpdateDomainsApiV1DomainsBatchUpdatePost>>, {data: BatchUpdateDomainsRequest}> = (props) => {
          const {data} = props ?? {};

          return  batchUpdateDomainsApiV1DomainsBatchUpdatePost(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type BatchUpdateDomainsApiV1DomainsBatchUpdatePostMutationResult = NonNullable<Awaited<ReturnType<typeof batchUpdateDomainsApiV1DomainsBatchUpdatePost>>>
    export type BatchUpdateDomainsApiV1DomainsBatchUpdatePostMutationBody = BatchUpdateDomainsRequest
    export type BatchUpdateDomainsApiV1DomainsBatchUpdatePostMutationError = HTTPValidationError

    /**
 * @summary Batch Update Domains
 */
export const useBatchUpdateDomainsApiV1DomainsBatchUpdatePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof batchUpdateDomainsApiV1DomainsBatchUpdatePost>>, TError,{data: BatchUpdateDomainsRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof batchUpdateDomainsApiV1DomainsBatchUpdatePost>>,
        TError,
        {data: BatchUpdateDomainsRequest},
        TContext
      > => {
      return useMutation(getBatchUpdateDomainsApiV1DomainsBatchUpdatePostMutationOptions(options), queryClient);
    }
    