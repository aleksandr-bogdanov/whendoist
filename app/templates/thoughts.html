{% extends "base.html" %}

{% block title %}Thoughts - Whendoist{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="/static/css/dashboard.css?v={{ app_version|default('') }}">
<link rel="stylesheet" href="/static/css/dialog.css?v={{ app_version|default('') }}">
<link rel="stylesheet" href="/static/css/pages/thoughts.css?v={{ app_version|default('') }}">
{% endblock %}

{% block content %}
<div class="thoughts-page">
    <h1 class="thoughts-title">Thought Cabinet</h1>
    <p class="thoughts-subtitle">Quick capture for ideas, tasks, and notes</p>

    <div class="thoughts-chat">
        <div class="scroll-area" id="scroll-area">
            <div class="scroll-spacer"></div>
            <div class="bubble-list" id="bubble-list">
                {% if thought_groups %}
                    {% for group in thought_groups %}
                    <div class="time-sep"><span>{{ group.label }}</span></div>
                    {% for task_item in group.thoughts %}
                    {% set task = task_item.task %}
                    <div class="bubble-row" data-task-id="{{ task.id }}" data-title="{{ task.title }}">
                        <div class="bubble-content">
                            <span class="bubble-text">{% if encryption_enabled %}ðŸ”’{% else %}{{ task.title }}{% endif %}</span>
                        </div>
                        <div class="bubble-actions">
                            <button type="button" class="icon-btn promote" title="Promote to Task" aria-label="Promote to Task">
                                <svg class="icon icon-xs" aria-hidden="true">
                                    <use href="{{ url_for('static', path='img/icons/ui-icons.svg') }}#arrow-up"></use>
                                </svg>
                            </button>
                            <button type="button" class="icon-btn delete" title="Delete" aria-label="Delete">
                                <svg class="icon icon-xs" aria-hidden="true">
                                    <use href="{{ url_for('static', path='img/icons/ui-icons.svg') }}#close"></use>
                                </svg>
                            </button>
                        </div>
                    </div>
                    {% endfor %}
                    {% endfor %}
                {% else %}
                    <div class="thought-empty-state" id="thought-empty">
                        <img src="{{ url_for('static', path='img/illustrations/empty-thoughts.svg') }}" alt="" class="empty-state-illustration" width="100" height="100" aria-hidden="true">
                        <p class="empty-state-text">No thoughts yet. Start typing below.</p>
                    </div>
                {% endif %}
            </div>
        </div>

        <div class="bottom-bar">
            <input type="text"
                   id="quick-add-input"
                   class="bottom-bar-input"
                   placeholder="Capture a thought..."
                   autocomplete="off"
                   aria-label="Capture a thought">
            <button type="button" class="bottom-bar-btn" id="thought-submit-btn" aria-label="Add thought">
                <span class="submit-label">Enter</span>
                <svg class="submit-icon icon icon-xs" aria-hidden="true">
                    <use href="{{ url_for('static', path='img/icons/ui-icons.svg') }}#arrow-up"></use>
                </svg>
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="/static/js/recurrence-picker.js"></script>
<script src="/static/js/task-dialog.js"></script>

<!-- E2E Encryption: Decrypt thought titles on page load -->
<script>
(async function decryptThoughtTitles() {
    if (!Crypto.canCrypto()) {
        return;
    }

    function looksEncrypted(value) {
        if (!value || value.length < 38) return false;
        return /^[A-Za-z0-9+/]+=*$/.test(value);
    }

    const bubbleRows = document.querySelectorAll('[data-title]');
    if (bubbleRows.length === 0) return;

    for (const el of bubbleRows) {
        const title = el.dataset.title;
        if (!title) continue;

        try {
            const displayTitle = looksEncrypted(title)
                ? await Crypto.decryptField(title)
                : title;

            if (!displayTitle) continue;

            const textEl = el.querySelector('.bubble-text');
            if (textEl) {
                textEl.textContent = displayTitle;
            }
        } catch (e) {
            console.error('Failed to decrypt thought title:', e);
            const textEl = el.querySelector('.bubble-text');
            if (textEl) {
                textEl.textContent = title;
            }
        }
    }
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const input = document.getElementById('quick-add-input');
    const bubbleList = document.getElementById('bubble-list');
    const scrollArea = document.getElementById('scroll-area');
    const emptyState = document.getElementById('thought-empty');

    let thoughtCount = {{ total_count|default(0) }};
    let todaySeparatorAdded = false;

    function scrollToBottom() {
        scrollArea.scrollTop = scrollArea.scrollHeight;
    }

    // Scroll to bottom on load
    scrollToBottom();

    function maybeAddTodaySeparator() {
        if (todaySeparatorAdded) return;
        todaySeparatorAdded = true;

        // Check if last separator is already "Today"
        const seps = bubbleList.querySelectorAll('.time-sep span');
        if (seps.length > 0 && seps[seps.length - 1].textContent === 'Today') {
            return;
        }

        const sep = document.createElement('div');
        sep.className = 'time-sep';
        sep.innerHTML = '<span>Today</span>';
        bubbleList.appendChild(sep);
    }

    async function submitThought() {
        if (!input.value.trim()) return;
        const title = input.value.trim();
        input.value = '';

        try {
            const encryptedTitle = await Crypto.encryptField(title);

            const response = await safeFetch('/api/v1/tasks', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title: encryptedTitle })
            });

            if (response.ok) {
                const task = await response.json();
                task.title = title;
                addThoughtToList(task);
            }
        } catch (err) {
            console.error('Failed to create thought:', err);
        }
    }

    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitThought();
        }
    });

    document.getElementById('thought-submit-btn').addEventListener('click', () => {
        submitThought();
        input.focus();
    });

    function addThoughtToList(task) {
        if (emptyState) {
            emptyState.remove();
        }

        maybeAddTodaySeparator();

        const row = document.createElement('div');
        row.className = 'bubble-row is-new';
        row.dataset.taskId = task.id;
        row.dataset.title = task.title;
        const iconSprite = '{{ url_for("static", path="img/icons/ui-icons.svg") }}';
        row.innerHTML = `
            <div class="bubble-content">
                <span class="bubble-text">${escapeHtml(task.title)}</span>
            </div>
            <div class="bubble-actions">
                <button type="button" class="icon-btn promote" title="Promote to Task" aria-label="Promote to Task">
                    <svg class="icon icon-xs" aria-hidden="true">
                        <use href="${iconSprite}#arrow-up"></use>
                    </svg>
                </button>
                <button type="button" class="icon-btn delete" title="Delete" aria-label="Delete">
                    <svg class="icon icon-xs" aria-hidden="true">
                        <use href="${iconSprite}#close"></use>
                    </svg>
                </button>
            </div>
        `;

        bubbleList.appendChild(row);
        attachRowListeners(row);
        thoughtCount++;

        // Animate and scroll
        requestAnimationFrame(() => {
            scrollToBottom();
            setTimeout(() => row.classList.remove('is-new'), 700);
        });
    }

    let pendingDeletion = null;
    let deletionTimeout = null;
    const DELETION_DELAY = 5000;

    function attachRowListeners(row) {
        const taskId = row.dataset.taskId;

        row.querySelector('.delete').addEventListener('click', () => {
            const title = row.querySelector('.bubble-text').textContent || 'Thought';
            const parent = row.parentElement;
            const nextSibling = row.nextSibling;

            if (pendingDeletion) {
                executeThoughtDelete(pendingDeletion.taskId);
            }

            row.remove();
            thoughtCount--;

            pendingDeletion = { taskId, row, parent, nextSibling };

            if (window.Toast) {
                Toast.show(`"${title}" deleted`, {
                    onUndo: () => undoThoughtDelete()
                });
            }

            if (deletionTimeout) clearTimeout(deletionTimeout);
            deletionTimeout = setTimeout(() => executeThoughtDelete(taskId), DELETION_DELAY);
        });

        row.querySelector('.promote').addEventListener('click', () => {
            if (window.TaskDialog) {
                TaskDialog.open(parseInt(taskId, 10));
            }
        });
    }

    function undoThoughtDelete() {
        if (!pendingDeletion) return;

        const { row, parent, nextSibling } = pendingDeletion;

        if (deletionTimeout) {
            clearTimeout(deletionTimeout);
            deletionTimeout = null;
        }

        if (parent) {
            if (nextSibling && nextSibling.parentNode === parent) {
                parent.insertBefore(row, nextSibling);
            } else {
                parent.appendChild(row);
            }
        }

        thoughtCount++;
        pendingDeletion = null;
    }

    async function executeThoughtDelete(taskId) {
        if (pendingDeletion && pendingDeletion.taskId !== taskId) return;

        pendingDeletion = null;
        if (deletionTimeout) {
            clearTimeout(deletionTimeout);
            deletionTimeout = null;
        }

        try {
            await safeFetch(`/api/v1/tasks/${taskId}`, { method: 'DELETE' });
        } catch (err) {
            console.error('Failed to delete:', err);
            if (window.Toast) {
                Toast.show('Failed to delete', { showUndo: false });
            }
        }
    }

    document.querySelectorAll('.bubble-row').forEach(attachRowListeners);

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
});
</script>
{% endblock %}
